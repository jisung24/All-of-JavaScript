/**
 * ==================== << 값에 대해서.. >> ====================
 * ### << 변수 >> ###
 *  #0) 정의 : 어떤 값에 이름을 붙여서 저장하고싶을 때! ==> 계속 미래에 쓰기 위한 값.
 *  #1) 선언 초기화 할당
 *    -1) 선언 : 변수 이름을 실행 컨텍스트에 등록을 해서 자바스크립트 엔진에 변수의 이름을 알린다.(아직 사용할 수 없다.)
 *    -2) 초기화 : 선언된 변수 이름을 위해 메모리 공간을 할당하고 암묵적으로 undefined를 할당한다.
 *    -3) 할당 : (=)할당 연산자를 이용해 필요한 값을 직접 대입해준다.! ex) const myName = '김지성'
 *  #2) hoisting
 *    - 정의 : 쉽게 말 해서 런타임 전에 실행 컨텍스트 단계 때 선언문들이 전부 가장 위로 끌어올려 지는 것을 의미한다.
 *             var같은 경우엔 호이스팅 되는 순간 초기화도 같이 진행이 돼서 사용할 수 있음.
 *             (이미 준비 된 투수라고 생각하면 돼!! ==> 이미 undefined가 초기화 돼서 나와.)
 *             스코프 단위이다!!!!! 
 * 
 * hoisting 정리 : 즉 호이스팅이 먼저 발생이 됨. 이후에 var let const function식별자들은 선언이 돼서
 *          실행 컨텍스트에 올라가게 되고, 이때 var같은 경우엔 선언과 초기화가 동시에 진행이 된다.
 *          =============== 여기까지가 실행 컨텍스트 단계야!!!! ===============
 *          런타임 때는 이제 진짜 코드가 실행이 된다. 
 *          
 *  what is TDZ(Temperary Dead Zone)
 *  ==> 호이스팅 후 선언이 되는 건 맞으나.. 초기화 즉 메모리 할당 전 까진 변수를 사용할 수 없는데,
 *      이떄 TDZ라는 ZONE에 가 있게 된다.   
 * 
 *       이렇게 정리하면 완벽해! 
 * 
 *  #3) let const var의 차이!(scope도 함께 다룸!)
 * 
 *    -1) 동일한 이름으로 재선언이 가능?   
 *        var : 동일한 이름으로 재선언이 가능하다. (실행 컨텍스트 단계 때 이름 같은 식별자 통과시킴..)
 *        let const : 이름 겹치면 안 돼!!!
 *    -2) 재할당 
 *        var let : 가능
 *        const : 상수여서 한 번 정한 값은 다시는 바꿀 수 없다. 
 *    -3) 스코프
 *        var(함수레벨스코프) : 함수블록 안에서만 지역변수이고 나머지에서는 전부 전역변수로 쓰인다.
 *        let const(블록레벨스코프) : 그냥 모든 블록 안에서 지역변수
 *    -4) 호이스팅
 *        var은 호이스팅 시 실행 컨텍스트 안에서 선언과 초기화가 동시에 일어난다.
 *        let,const도 호이스팅은 됨!!! 하지만 초기화,실행이 런타임 때 발생한다.
 *         ==> 따라서 let const는 tdz에 있으며, 초기화가 런타임때 되기 때문에 선언 전에 사용할 수 없다. 
 *    -5) 전역객체 프로퍼티 
 *         var은 전역객체의 프로퍼티가 된다. 
 *         let const는 전역객체의 프로퍼티가 되지않는다. 
 *    
 * ================================ << 결론 >> ================================
 * 1. 일단 실행(ctrl + alt + n)을 누르면 실행 컨텍스트 단계 때 호이스팅이 되고 각 변수들은 실행 컨텍스트에 놓이게된다.
 * 2. var같은 경우엔 실행 컨텍스트에 놓이는 순간 초기화가 진행된다.
 * 3. 이제 런타임에 돌입한다.
 * ==> let const는 초기화가 런타임때 코드에서 직접 우리가 해줘야해서, 미리 선언전에 사용할 수 없는 것 이다. 
 * ==> 즉 초기화코드를 만나기 전 까진 let const선언 변수들은 사용할 수 없는데,
 * ==> 이 때! TDZ 일시적으로 죽은 지역이라는 곳에 위치하게 된다.(초기화코드를 런타임때 만나기 전 까진 사용할 수 없는 변수.)
 * 
 * */

// <<  var특징  ==> 1.선언과 초기화 동시 진행.  >>
console.log(a); //이미 호이스팅 이후 컨텍스트때 초기화까지 다 돼서 런타임(실제 코드 한줄씩 실행)에 돌입한다.
var a = 3; //쉽게 이해하면 var로 하는 순간 이미 undefined가 초기화 됐다고 생각해주면 마음 편함.
var a = 5; //같은 이름으로 재선언이 가능하다는 말도안되는 특징이 있음. 나중에 코드 길어지면 큰일날거같아....
// <<  var특징2 ==> 함수 스코프!  >>
function add(num1,num2){ //함수 선언!
    var sum = num1 + num2;
    return sum;
}
console.log(`더하기 >> ${add(1,2)}`); //호출!
// console.log(sum); //함수밖에서는 접근할 수 없다. 

// let
console.log(let_a); //초기화문을 만나기 전 까진 쓸 수 없다!!!
let let_a = 3;
let_a = 4; //재할당 가능 ==> 값을 변경할 수 있다.!!! const와의 차이점!

{
    let b = 43;
    console.log(b);
    b++;
}
console.log(b); //블록 밖에서는 접근이 불가하다. 

// << const >> 
const go = 3;
go = 4; //재할당이 불가하다.

//마찬가지로 const도 블록scope이다! 
